<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>2024&period;02&period;16</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h3 id="20240216">2024.02.16</h3>
<h3 id="자료구조와-함께-배우는-알고리즘-입문-p122_q5">자료구조와 함께 배우는 알고리즘 입문 p.122_Q5</h3>
<h1 id="find-the-element-at-the-front"><strong>Find the Element at the Front</strong></h1>
<h2 id="1-code">1. code</h2>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* a, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* b)</span> {
   <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*)a &lt; *(<span class="hljs-type">int</span>*)b) {
   	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
   }
   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*)a &gt; *(<span class="hljs-type">int</span>*)b) {
   	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
   }
   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">search_idx</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span> {
   <span class="hljs-type">int</span> *q = bsearch(&amp;key, a, n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), compare);
   <span class="hljs-type">int</span> idx = (<span class="hljs-type">int</span>) (q - a);
   <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
   	<span class="hljs-keyword">if</span> (a[idx<span class="hljs-number">-1</span>] == a[idx]) {
   		idx--;		}
   }
   <span class="hljs-keyword">return</span> idx;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
   <span class="hljs-type">int</span> n, key;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size of array : &quot;</span>);
   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);
   <span class="hljs-type">int</span>* x = <span class="hljs-built_in">calloc</span>(n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));
   <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">NULL</span>) {
   	<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;fail to allocate memory&quot;</span>);
   }

   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x[%d] : &quot;</span>, <span class="hljs-number">0</span>);
   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x[<span class="hljs-number">0</span>]);
   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
   	<span class="hljs-keyword">while</span> (x[i] &gt; x[i - <span class="hljs-number">1</span>]); {
   		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x[%d] : &quot;</span>, i);
   		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x[i]);
   	}
   }

   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Key to find : &quot;</span>);
   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;key);

   <span class="hljs-type">int</span> first = search_idx(x, n, key);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, first);

   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<h2 id="2-output">2. output</h2>
<p><img src="file:///c:\Users\dbstj\report\p.122_Q5.png" alt="alt text"></p>
<hr>
<h2 id="3-analysis">3. Analysis</h2>
<h3 id="how-to-approach">How to approach</h3>
<p>Binary search has two characteristics.<br>
The array of search targets should always be aligned.Also, if you have multiple elements, such as the value you search for, you don't always find the element at the front.<br>
However, in this problem, if the value of the index found using binary search is the same as the value immediately preceding it, idx is reduced by 1. Repeating this until it is different from the previous value returns the result.</p>
<h3 id="pros-and-cons">Pros and Cons</h3>
<p>We can overcome the shortcomings of binary as a function to find the element in front of us.<br>
<em>However, through repetitions, the time complexity became O(n).</em></p>

            
            
        </body>
        </html>
